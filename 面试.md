## SQL
### 三范式
#### 第一范式（1NF）：
数据库中的每个列都是原子的，不可再分的。每个列的值都是不可再分的基本数据类型，如整数、字符串、日期等。
有主键，每个列都是原子的，不可再分的。如果有表里有一个字段是存放地址信息，存在省市区这样的概念，那就是不满足第一范式的。
该范式消除了重复的数据项，确保每个数据项的唯一性。
#### 第二范式（2NF）：
在满足1NF的基础上，数据库中的每个非主键列完全依赖于主键。换句话说，每个非主键列都与主键形成完整的依赖关系。
在满足1NF的基础上，数据库中的每个非主键列完全依赖于主键，也就是一个数据库表中只能存放一种信息。
比如说有一个学生表，里面存放学生ID，name，age,sex,还存放学生父亲ID，父亲姓名，这样就是不符合要求的
如果存在复合主键，则每个非主键列都必须依赖于所有主键列，而不仅仅依赖于部分主键列。
#### 第三范式（3NF）：
在满足2NF的基础上，数据库中的每个非主键列都不传递依赖于主键。换句话说，任何非主键列都不能依赖于其他非主键列。
在满足1NF，2NF的基础上，数据库中的每个非主键列都不传递依赖于主键。换句话说，任何非主键列都不能依赖于其他非主键列。
比如说，还是个学生表，，里面存放学生ID，name，age,sex,还有学校姓名，学校地址，学校联系电话，这样就不符合要求。学校姓名，学校地址，学校联系电话存在依赖关系。
该范式通过消除传递依赖关系，确保数据的非冗余性和一致性

### 优化查询语句：
- 确保使用合适的查询条件，使用 WHERE 子句限制结果集的大小。
- 避免使用通配符 "%" 开头的模糊查询，因为它会导致全表扫描。
- 避免在查询中频繁使用函数，特别是在 WHERE 子句中，因为它会导致索引失效。
- 尽量避免使用子查询，可以使用 JOIN 或其他关联方式来替代。
- 避免多次查询相同的数据，可以使用临时表或子查询来存储查询结果，以便后续复用。
- 避免使用 SELECT *
- 使用 UNION ALL 替代 UNION：UNION ALL 全部数据，UUNION 去掉重复数据
- 使用分页查询：limit，top

### 级联更新与级联删除
- 我对一端主键进行修改时，多端外键同时被修改
- 我对一端主键进行删除时，多端外键同时被删除


### 开窗函数 用PARTITION BY分组 ORDER BY排序
#### ROW_NUMBER()
#### ROW_NUMBER()1，2，3...
为结果集中的每一行分配一个唯一的整数值，常用于对结果集进行编号。可以处理重复数据
```sql
SELECT ROW_NUMBER() OVER (ORDER BY column_name) AS row_num, column_name
FROM table_name;
```
SELECT *
FROM (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY product_name,Amount ORDER BY insert_date) AS row_num
    FROM Product
) AS temp
WHERE row_num > 1;  删除重复数据

#### RANK()
#### RANK()1,1,3..
根据指定的排序顺序，为结果集中的每一行分配一个排名，如果有相同值，则会跳过下一个排名
```sql
SELECT RANK() OVER (ORDER BY column_name) AS rank_num, column_name
FROM table_name;
```
#### DENSE_RANK() 
#### DENSE_RANK() 1,1,2..
根据指定的排序顺序，为结果集中的每一行分配一个密集排名，如果有相同值，则会跳过下一个排名，但不会留下空缺。
```sql
SELECT DENSE_RANK() OVER (ORDER BY column_name) AS dense_rank_num, column_name
FROM table_name;
#### 
```
#### SUM() 累加
```sql
SELECT column_name, SUM(column_name) OVER (PARTITION BY partition_column) AS total_sum
FROM table_name;
```
SELECT product_name, sale_date, sale_amount,
SUM(sale_amount) OVER (PARTITION BY product_name ORDER BY sale_date) AS cumulative_sales
FROM sales; 计算累计销售额

#### AVG()
```sql
SELECT column_name, AVG(column_name) OVER (PARTITION BY partition_column) AS average_value
FROM table_name;
```
### 计算每个员工的销售额，并显示该员工的销售额与部门平均销售额的差异。
```sql
select employee_id,sale_amount,
avg(sale_amount) over (partition by department_id) as avg_amount,
sale_amount - avg(sale_amount) over (partition by department_id) as diff_amount
from sales2
```

## AWS
### 跨账号IAM角色访问
- 中央身份账户体系
- 建立中央身份账户，集中为组织建立用户、密码以及访问密钥，进行统一管理用户。
- 
#### A账户
- 创建一个IAM用户，zhangsan
- 为用户zhangsan配置允许切换到B中角色的权限
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "sts:AssumeRole",
      "Resource": "arn:aws:iam::B-ACCOUNT-ID:role/test-role"
    }
  ]
}
```
#### B账户
- 创建一个角色test-role，受信任实体为其他aws账户，指定A账户的accountid
- 权限策略给上S3存储桶的权限AmazonS3FullAccess
- 信任关系里编辑AssumeRole,可以将principal设置为A的root
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::A-ACCOUNT-ID:root"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}

Switch role 的链接信息，存放在B账户的test-role的摘要页面里，点击进来就完成了将A账户用户访问B账户S3存储桶

```
- 配置存储桶策略
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::A-ACCOUNT-ID:root"
      },
      "Action": "s3:*",
      "Resource": [
          "arn:aws:s3:::xxxxxx",
          "arn:aws:s3:::xxxxxx/*"
      ]
    }
  ]
}
```

## Informatica 相关
###优化
- 在源和目标数据库中创建合适的索引，以加速数据的读取和写入操作。
- 使用数据库统计信息，确保查询优化器能够生成最佳的查询执行计划。
- 将mapping的目标分解，保留一个目标
- 在join、agg之前排序器转换组件
- 使用filter组件时，若过滤条件复杂，可以先使用exporession组件生成类似条件字段，然后在filter组件使用该字段过滤可大大提高性能

### joiner和lookup转换组件的区别
#### Joiner 转换：
- Joiner 转换用于将两个或多个输入数据流连接在一起，基于指定的连接条件将它们合并成一个输出数据流。
- Joiner 转换可以实现不同数据源之间的连接操作，类似于 SQL 中的 JOIN 操作。
- Joiner 转换适用于连接那些在结构上相互独立的数据流，通常需要在转换之前对输入数据进行排序操作。
- Joiner 转换支持多种连接类型，如等值连接、外连接等。
#### Lookup 转换：
- Lookup 转换用于在源数据集中查找匹配条件的记录，并将查找到的数据添加到目标数据流中。
- Lookup 转换通常用于根据某个键值在查找表或参考表中查找相应的数据，并将查找到的数据合并到主数据流中。
- Lookup 转换适用于需要从参考表或查找表中获取额外信息的情况，类似于 SQL 中的 JOIN 操作。
- Lookup 转换支持不同的查找模式，如查询模式、更新模式、插入/更新模式等，以满足不同的数据需求。
因此，Joiner 转换主要用于连接不同数据源之间的数据，而 Lookup 转换主要用于在源数据中查找参考表或查找表的匹配数据。它们的使用场景和功能略有不同，根据实际需求选择合适的转换组件进行数据集成和转换操作。
## Shell 命令
- `ls`：列出目录内容。
示例：ls -l，显示详细信息；ls -a，显示隐藏文件。
- `cd`：切换当前工作目录。
示例：cd /path/to/directory，切换到指定目录；cd ..，切换到上级目录。
- `mkdir`：创建新目录。
示例：mkdir new_directory，创建名为 "new_directory" 的新目录。
- `cp`：复制文件或目录。
示例：cp file1.txt file2.txt，将 "file1.txt" 复制为 "file2.txt"。
- `mv`：移动文件或目录，也可用于重命名。
示例：mv file1.txt /path/to/directory，将 "file1.txt" 移动到指定目录。
- `rm`：删除文件或目录。
示例：rm file.txt，删除名为 "file.txt" 的文件；rm -r directory，删除名为 "directory" 的目录。
- `touch`：创建空文件或修改文件时间戳。
示例：touch new_file.txt，创建名为 "new_file.txt" 的空文件。
- `cat`：查看文件内容。
示例：cat file.txt，显示 "file.txt" 文件的内容。
- `grep`：在文件中搜索指定的模式。
示例：grep "pattern" file.txt，搜索文件中匹配指定模式的行。
- `chmod`：修改文件或目录的权限。
示例：chmod +x script.sh，给脚本 "script.sh" 添加执行权限
- `top`：实时监控系统的进程和资源使用情况。
示例：top
- `ps`：查看当前系统中运行的进程。
示例：ps aux
- `free`：显示系统的内存使用情况。
示例：free -h

## 数仓
### 缓慢变化维
缓慢变化维是指在数据仓库中，用于存储维度数据的表，它的数据会随着时间的推移而发生变化，这种变化是缓慢的，而不是瞬间发生的。
- SCD Type 1（SCD1）：当维度数据变化时，直接覆盖原有数据，不保留历史记录。这种方法适用于不需要保留历史变化的情况，只关注当前状态的维度数据。新数据将完全替代旧数据。
- SCD Type 2（SCD2）：当维度数据发生变化时，保留原有记录，并添加新记录来反映变化。这样可以保留历史数据，以便进行时间分析和趋势分析。通常，在SCD2中，会添加一个生效日期和失效日期的列，用于标识每个版本的有效时间范围。
- SCD Type 3（SCD3）：在维度数据变化时，保留原有记录，并添加一些附加列来跟踪变化。通常，这些附加列用于存储先前的属性值，以便进行部分历史分析。SCD3相对于SCD2来说，对历史数据的保留更有限，只关注一些关键变化。

#### 假设我们有一个产品维度表，包含以下列：

- 产品ID（Product ID）
- 产品名称（Product Name）
- 产品类型（Product Type）
- 生效日期（Effective Date）
- 失效日期（Expiration Date）
#### 设计逻辑如下：
- `初始状态`：在数据仓库中加载初始产品维度数据，每个产品有唯一的产品ID，产品名称，产品类型等属性，同时设置生效日期和失效日期为空。

- `变化发生`：当产品维度数据发生变化时，例如产品名称的修改，需要进行以下步骤： 
  - 在维度表中查找具有相同产品ID的最新记录，检查其失效日期是否为空。如果失效日期为空，将其设置为当前日期，表示该记录不再有效。
  - 创建一条新的记录，拷贝原有记录的产品ID，产品类型等属性，并更新产品名称为新值，同时设置生效日期为当前日期，失效日期为空。
  - 历史记录保留：通过保留历史记录，我们可以跟踪产品名称的变化。在维度表中，会存在多个具有相同产品ID的记录，但生效日期和失效日期不同。这样，我们可以根据需要进行历史数据查询和分析。

#### 举个例子：
假设有一个产品ID为 "P001" 的产品，在初始状态下，产品名称为 "Product A"，类型为 "Type 1"。后来，产品名称变更为 "Product A Updated"。根据SCD2的设计逻辑，我们会进行如下操作：
- 在维度表中查找产品ID为 "P001" 且失效日期为空的记录，假设该记录的生效日期为 "2022-01-01"。
- 将该记录的失效日期设置为 "2022-05-01"，表示该记录在 "2022-05-01" 不再有效。
- 创建一条新记录，拷贝产品ID、类型等属性，并将产品名称设置为 "Product A Updated"，生效日期设置为 "2022-05-01"，失效日期为空。
通过这种方式，我们可以在数据仓库中保留历史产品名称的变化记录，同时提供了当前有效的产品信息。这样，我们可以根据需要进行历史数据分析和趋势分析，同时保持维度数据的一致性和准确性。

### 事实表
事实表（Fact Table）是数据仓库中的一种关键表格，用于存储与业务事实和度量相关的数据。事实表包含了多个度量（Measure）列和与其关联的外键列，用于与维度表建立关联。
#### 以下是事实表的一些特点和设计要点：
- `存储度量数据`：事实表存储了与业务过程、事件或交易相关的数值型度量数据，例如销售金额、订单数量、库存量等。这些度量数据是可以被聚合和分析的关键指标。
- `外键关联维度表`：事实表通过外键与一个或多个维度表进行关联。这些外键通常是指向维度表中的主键列，用于连接事实表和维度表，以提供更多的上下文信息和分析维度。
- `粒度（Granularity）`：事实表的粒度是指每个事实记录所代表的业务事件或事实的详细程度。粒度决定了事实表的行数和存储的详细程度。例如，销售事实表可以以每个订单为粒度，或者更细粒度地以每个订单行为粒度。
- `聚合层次`：事实表可以包含多个层次的度量数据，从较粗粒度的聚合数据到更细粒度的原始数据。这样可以支持不同层次的分析和报表需求，提供灵活性和性能优化。
- `时态数据`：某些情况下，事实表还可以存储时态数据，即描述时间的变化。例如，销售事实表可以包含销售日期列，以支持时间维度的分析和趋势分析。
- `可更新性`：事实表通常是一个只读的表，用于存储历史数据，不会频繁更新。数据仓库中的ETL过程负责将源系统的数据转换和加载到事实表中。
事实表的设计和建模需要考虑业务需求、分析要求和性能优化等因素。它提供了与维度表关联的度量数据，为数据仓库用户提供了丰富的分析能力，支持业务决策和洞察力的提升。

### 维度表
（Dimension Table）是数据仓库中的一种关键表格，用于存储与业务实体相关的描述性属性。维度表包含了维度属性列和与其关联的主键列，用于与事实表建立关联。
#### 以下是维度表的一些特点和设计要点：
- `存储描述性属`性：维度表存储与业务实体相关的描述性属性，例如产品、客户、时间等。这些属性用于提供上下文信息，帮助解释和分析事实表中的度量数据。
- `主键列`：维度表中的主键列是唯一标识每个维度实体的列。主键用于与事实表中的外键建立关联，实现维度和事实之间的关系。主键通常是一个稳定的标识符，不随时间或其他变化而改变。
- `描述性属性列`：维度表包含了描述性属性列，用于存储与维度实体相关的属性信息。例如，产品维度表可以包含产品名称、产品类型、制造商等属性列。这些属性提供了对维度实体的详细描述和分类。
- `层次结构`：维度表可以包含多个层次结构，用于提供维度数据的不同层次视图。例如，时间维度表可以包含年、季度、月份、日期等层次结构，以支持不同层次的时间分析和聚合。
- `可选属性和衍生属性`：维度表可以包含可选的属性列，用于提供更多的维度信息。此外，还可以包含衍生属性，这些属性是通过计算或转换从原始属性派生而来的。
- `缓慢变化维度处理`：维度表通常需要考虑缓慢变化维度（Slowly Changing Dimensions，SCD）的处理，以管理维度数据的变化。不同的SCD类型（如SCD1、SCD2）可以应用于维度表，以满足业务需求和数据历史追溯的要求。
- `可更新性`：维度表通常是一个只读的表，用于存储静态的描述性属性。在数据仓库中的ETL过程负责将源系统中的数据转换和加载到维度表中。
维度表的设计和建模需要考虑业务需求、数据分析的灵活性以及性能优化等因素。它提供了用于解释和分析事实表中度量数据的上下文信息，为数据仓库用户提供了丰富的维度分析能力。通过与事实表的关联，维度表支持复杂的查询、切片和钻取操作，从而支持业务决策和分析的需求。

## 业务
### 1. 什么是财务预提？
财务预提是指在财务报表中，为了符合会计准则，而在当期已发生但尚未确认的费用或收入，通过预提的方式，提前计入当期的费用或收入，从而使当期的财务报表更加准确。
### 2. 举例说明
假设某公司在2019年12月31日，已经发生了2019年12月份的工资费用，但是由于工资发放时间的原因，工资费用尚未确认，那么在2019年12月31日，公司就需要通过预提的方式，将2019年12月份的工资费用计入2019年的费用，从而使2019年的财务报表更加准确。

## Internal Order
### 1. 什么是内部订单？
内部订单是指在SAP系统中，用于跟踪和监控公司内部的成本和收入的订单，它可以用于跟踪和监控公司内部的成本和收入，也可以用于跟踪和监控公司内部的投资项目。
- 项目成本控制：内部订单可用于跟踪特定项目的成本和支出。这使得管理层能够准确评估项目的财务状况，及时进行预算控制和决策。
- 部门成本分配：内部订单可以用于将成本和费用分配给组织中的不同部门或成本中心。这有助于了解每个部门的运营成本，评估其绩效，并进行资源优化。
- 活动成本追踪：内部订单可用于追踪特定活动或业务过程的成本和效益。这有助于识别成本效益低下的活动，并进行改进和优化。

## 成本中心
1. 成本中心是指企业内部的一个组织单位、部门或区域，用于追踪和管理特定的成本和费用。它是成本管理的一个重要概念，旨在帮助企业了解和控制不同业务活动的成本。
2. 成本中心可以是一个部门，如销售部门、生产部门、人力资源部门等，也可以是一个特定的项目、产品线或地理位置。每个成本中心通常与特定的管理责任人和预算相关联。
3. 通过设立成本中心，企业可以更好地了解不同部门或业务活动的成本和开支情况。成本中心通常会记录和追踪与该部门相关的直接费用（如工资、材料费用）和间接费用（如租金、设备折旧、行政费用）。这样，企业可以更好地评估每个成本中心的绩效和效益，并采取相应的管理措施。
### 成本中心的设置和管理有助于实现以下目标：
- 成本控制：通过追踪和监控成本中心的费用，企业可以更好地控制和管理成本，识别潜在的成本节约机会。
- 绩效评估：成本中心的设置使企业能够评估各个部门或业务活动的绩效。通过比较实际成本和预算成本，可以确定绩效差异，并采取适当的措施进行改进。
- 决策支持：成本中心提供了可靠的数据和信息，支持管理层在做出决策时考虑成本因素。它可以帮助管理层识别哪些部门或活动对企业贡献最大，以及哪些部门需要改善和优化。

总之，成本中心是企业内部用于追踪、管理和控制特定成本和费用的单位或部门，有助于企业进行成本管理、绩效评估和决策支持。


